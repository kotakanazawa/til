これを読んでいく。
[\[ActiveRecord\] 複数のモデルにまたがる処理を書きたいときの設計方法](https://zenn.dev/igaiga/books/rails-practice-note/viewer/ar_processing_across_multiple_models)

複数のモデルにまたがる処理を実装したいときは、基本的に以下の3つを検討する。

- 主となるモデルに実装をする
- イベント型モデルを探す
- POROを作る

## 主となるモデルに実装をする

例えば、ECサービスのカートを実装する場合。

- Cartモデル：ユーザーごとのカートを管理する責務を持つ
- CartItemモデル：カート内の個々の商品を管理する責務を持つ

ある特定の商品を値引きするクーポンがあったとき、これを適用するのはCartモデルか、CartItemモデル、どちらにすべきか？
このときに、

- Cartモデル：主
- CartItemモデル：従

という関係性があると考えて、Cartモデルの責務としてクーポン適用のメソッドを実装するのが「主となるモデルに実装をする」方法となる。
この場合、おそらく`Cart has-many CartItem`という関係になるはず。

主となるモデルに実装をするメリット：

- モデルを増やさずに済む

まずこれで始めて、開発していく中でメソッドが増えてきてから分割や、「イベント型モデル」や「POROをつくる」をやっていく。最初からこの2つをやるのは難しい。

デメリット：

主従関係にあるか考えづらいモデル間ではどちらのモデルへ実装したらいいか迷う。

## イベント型モデルを探す

行為を記録するモデルをイベント型モデルと呼ぶ。イベント型モデルとは、「楽々ERDレッスン」で学んだイベント系エンティティのこと。「〜する」などの動詞で表現できるのがイベント。「入金する」「記録する」「予約する」などはイベント系エンティティとなる。

たとえば、商品を入荷するケースを考える。

- 在庫を増やす（Stockモデル）
- 支払った代金を銀行口座（BankAccountモデル）から減らす

これらをしたいときにどう設計するか。Stockモデル、BankAccountモデルにまたがる処理になるが、どちらのモデルに書くか？
こういったときに、行動に着目するときれいに設計できる。

この場合、「入荷する」行為をしているとみなす。つまり「入荷する（Arrivalモデル）」というイベント型モデルをつくる。

Arrivalモデルの責務：

- 在庫を増やす
- 支払った代金を銀行口座から減らす

イベントに着目することで、複数モデルにまたがる処理をきれいに1つのモデルにまとめることができる。

このイベント型モデルは必ずしもActiveRecordを継承してDBに記録しなくてもいい。最初にActiveModelとして設計したり、後述のPOROとしてただのRubyクラスで設計するのもOK。ディレクトリは`app/models`配下に配置していい。

将来DBに記録したくなったらActiveRecordを継承する形に書き換えてもいい。

## POROをつくる

POROとはPlain Old Ruby Objectの略称で、ActiveRecordやActiveModelなどを何も継承していないRubyのクラスのこと。複数モデルにまたがる処理を書く選択肢のひとつとして挙げられる。

ただし、これはRails wayからは外れるためチームで認識を合わせておくことが重要。

ファイルの配置は`app/models`でOK。

クラス名は、返すオブジェクトの名前を名詞でつける。これが作りやすいのでオススメ。

最初はPOROでつくって、データを永続化させたくなったらActiveRecordを継承してモデル化するのもよし。

## モデルを分割するタイミング

- 下手に分割するよりもFatモデルのほうがマシな場合もある
- [Ruby on Railsの正体と向き合い方 / What is Ruby on Rails and how to deal with it? \- Speaker Deck](https://speakerdeck.com/yasaichi/what-is-ruby-on-rails-and-how-to-deal-with-it)によると、「限界の表出の仕方の1つは、特定の条件でValidations/Callbacksを実行する or スキップすること」と話されている
  - モデルのバリデーションやコールバックを分岐するために`if: :condition?`, `on: :context`らが書かれたときや、保存時に`save(validate: false)`のようにバリデーションを実行しないコードが書かれたとき
  - これらが書かれたときはモデル分割の良いタイミング
- Fatモデルかどうかを行数で判断するのは良い方法ではない。各メソッドが独立して疎結合であれば、行数が多くても困ることは少ない

## フォームオブジェクトを使って分割する

- Railsでのモデルのバリデーションは、DBとフォームの両方で共通して使われる
- モデルにバリデーションを書くと、DBに対するバリデーションと、フォームでのバリデーションとで共用されて、多くのケースで都合が良い
- `validation`メソッドに分岐を書くとメンテナンスが難しくなる。このタイミングがモデル分割の良いタイミングとなり、フォームオブジェクトを使うとよい
- 各フォームごとにフォームオブジェクトをつくり、各フォームごとのバリデーションをフォームオブジェクトに実装する
- モデルにあるバリデーションは、DBのバリデーションに専業させる
- フォームオブジェクトをつくるときは、ActiveModel::Modelモジュール(Rails7.0以降はActiveModel::APIモジュールも新しく作られた)を`include`することで、属性のハッシュで初期化する機能や、バリデーションを設定して実行できる機能、`form_with`とやりとりする機能を簡単に追加できる

各APIリファレンス
- https://api.rubyonrails.org/classes/ActiveModel/Model.html
- https://api.rubyonrails.org/classes/ActiveModel/API.html

## Service層はなるべく入れない

- Service層を入れるのはアンチパターン
- Railsはレイヤー分割を減らして、コード量を減らす設計になっている
  - モデル層、コントローラー層などなど
  - 例：モデルはORマッパー、バリデーション、コールバック、フォームオブジェクト、ビジネスロジッ置き場になっている
- Railsのモデルは、一緒にクラスに集めて都合が良いものを集めることで、コード量を減らしている。そのため、層を増やすことはRailsの長所を消す行為となる
- Service層の別の問題として、開発メンバーが考えているServiceについての認識がバラバラになるといったことが起こりがち（これはめちゃよくわかる）
  - それぞれが「私の考えるService層」みたいなものを持ってしまい、議論に時間がかかることも
- Service層を入れるより、モデルの概念を拡張する、POROにするなどシンプルな考え方から始める
- Service層を入れたときの問題点：
  - Serviceオブジェクト間でメソッド共有がむずかしい
  - モデルと違った設計方針となるのでオブジェクトの責務の特徴を作りづらい
  - ビジネスロジックをどこへ書くか迷いやすい
