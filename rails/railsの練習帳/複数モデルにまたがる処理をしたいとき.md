これを読んでいく。
[\[ActiveRecord\] 複数のモデルにまたがる処理を書きたいときの設計方法](https://zenn.dev/igaiga/books/rails-practice-note/viewer/ar_processing_across_multiple_models)

複数のモデルにまたがる処理を実装したいときは、基本的に以下の3つを検討する。

- 主となるモデルに実装をする
- イベント型モデルを探す
- POROを作る

## 主となるモデルに実装をする

例えば、ECサービスのカートを実装する場合。

- Cartモデル：ユーザーごとのカートを管理する責務を持つ
- CartItemモデル：カート内の個々の商品を管理する責務を持つ

ある特定の商品を値引きするクーポンがあったとき、これを適用するのはCartモデルか、CartItemモデル、どちらにすべきか？
このときに、

- Cartモデル：主
- CartItemモデル：従

という関係性があると考えて、Cartモデルの責務としてクーポン適用のメソッドを実装するのが「主となるモデルに実装をする」方法となる。
この場合、おそらく`Cart has-many CartItem`という関係になるはず。

主となるモデルに実装をするメリット：

- モデルを増やさずに済む

まずこれで始めて、開発していく中でメソッドが増えてきてから分割や、「イベント型モデル」や「POROをつくる」をやっていく。最初からこの2つをやるのは難しい。

デメリット：

主従関係にあるか考えづらいモデル間ではどちらのモデルへ実装したらいいか迷う。

## イベント型モデルを探す

行為を記録するモデルをイベント型モデルと呼ぶ。イベント型モデルとは、「楽々ERDレッスン」で学んだイベント系エンティティのこと。「〜する」などの動詞で表現できるのがイベント。「入金する」「記録する」「予約する」などはイベント系エンティティとなる。

たとえば、商品を入荷するケースを考える。

- 在庫を増やす（Stockモデル）
- 支払った代金を銀行口座（BankAccountモデル）から減らす

これらをしたいときにどう設計するか。Stockモデル、BankAccountモデルにまたがる処理になるが、どちらのモデルに書くか？
こういったときに、行動に着目するときれいに設計できる。

この場合、「入荷する」行為をしているとみなす。つまり「入荷する（Arrivalモデル）」というイベント型モデルをつくる。

Arrivalモデルの責務：

- 在庫を増やす
- 支払った代金を銀行口座から減らす

イベントに着目することで、複数モデルにまたがる処理をきれいに1つのモデルにまとめることができる。

このイベント型モデルは必ずしもActiveRecordを継承してDBに記録しなくてもいい。最初にActiveModelとして設計したり、後述のPOROとしてただのRubyクラスで設計するのもOK。ディレクトリは`app/models`配下に配置していい。

将来DBに記録したくなったらActiveRecordを継承する形に書き換えてもいい。
